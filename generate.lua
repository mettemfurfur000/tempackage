-- generate.lua
-- Scans the local "src" directory (non-recursive) for files (not directories)
-- and writes a Lua file that returns a table with those filenames.
--
-- Output file: src_files.lua (placed next to this script)

local lfs_ok, lfs = pcall(require, "lfs")

local src_dir = "src"
local out_path = "src_files.lua"

local function is_dir(path)
    if lfs_ok then
        local a = lfs.attributes(path)
        return a and a.mode == "directory"
    end
    -- best-effort fallback: try to change to it
    local cur = lfs_ok and lfs.currentdir and lfs.currentdir() or nil
    return false
end

local function list_files_non_recursive(src)
    local files = {}

    if lfs_ok then
        local attr = lfs.attributes(src)
        if not attr or attr.mode ~= "directory" then
            return files
        end
        for name in lfs.dir(src) do
            if name ~= "." and name ~= ".." then
                local full = src .. "/" .. name
                local a = lfs.attributes(full)
                if a and a.mode == "file" then
                    table.insert(files, name)
                end
            end
        end
    else
        -- Fallback: try to use platform shell commands to list files only.
        local is_windows = package.config:sub(1,1) == "\\"
        local cmd
        if is_windows then
            -- dir /b /a-d lists files only (no directories)
            cmd = string.format('dir /b /a-d "%s"', src)
        else
            -- GNU find: print file basenames in src (non-recursive)
            -- If find with -maxdepth isn't available, this will likely be present on msys/git-bash environments.
            cmd = string.format('find %s -maxdepth 1 -type f -printf "%%f\n" 2>/dev/null', src)
        end

        local p = io.popen(cmd)
        if p then
            for line in p:lines() do
                if line ~= "" then
                    table.insert(files, line)
                end
            end
            p:close()
        end

        -- As a safety filter (in case command listed directories), verify each entry can be opened as a file.
        local filtered = {}
        for _, name in ipairs(files) do
            local full = src .. "/" .. name
            local f = io.open(full, "rb")
            if f then
                f:close()
                table.insert(filtered, name)
            end
        end
        files = filtered
    end

    table.sort(files)
    return files
end

local files = list_files_non_recursive(src_dir)

local function write_table(path, tbl)
    local f, err = io.open(path, "wb")
    if not f then
        io.stderr:write("Failed to open output file: ", tostring(err), "\n")
        return false
    end
    f:write("-- This file is generated by generate.lua\n")
    f:write("return {\n")
    for _, name in ipairs(tbl) do
        f:write("  ", string.format("%q", name), ",\n")
    end
    f:write("}\n")
    f:close()
    return true
end

local ok = write_table(out_path, files)
if ok then
    print("Wrote file list to " .. out_path .. " (" .. tostring(#files) .. " entries).")
else
    os.exit(1)
end